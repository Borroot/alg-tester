#!/usr/bin/env bash
# AUTHOR: Bram Pulles

# Default values.
PROGRAM="solver" 
SAMPLES_PATH="bin-tester/samples"

MAX_TIME="1"
DEBUG=false
RUN="./"

# Options for user input parsing.
OPTIONS=p:s:dm:hjc
LONGOPTS=program:,samples:,debug,max-time:,java,cpp,help

# Parse the options given by the user with getopt and format them correctly.
PARSED=$(getopt --options=$OPTIONS --longoptions=$LONGOPTS --name "$0" -- "$@")
parsed_correctly=$?
eval set -- "$PARSED"

# Help function.
function help {
	echo -e "
Usage: $0 [OPTIONS...]

This is an automatic testing tool for the algorithm and datastructures 
practicum. The script tries to run a C++ program by default. These 
default values can be changed inside the script at the top.

Options:
  -p,--program <path>    - Specify the path to your program
  -s,--samples <dir>     - Specify the path to your samples folder
  -m,--max-time <value>  - Specify the max time (s) to solve one case
  -d,--debug             - Show error messages (stderr)
  -c,--cpp               - Run a C++ solver.
  -j,--java              - Run a Java solver
  -h,--help              - Show this help

Written by Bram Pulles
"
}

# If getopt gives an error then quit and show help.
if [ $parsed_correctly -ne 0 ]
then
	echo "Use the option -h or --help for more information."
	exit $parsed_correctly
fi

# Parse options until '--'.
while true; do 
	case "$1" in
		-p|--program)
			PROGRAM="$2"
			shift 2
			;;
		-s|--samples)
			SAMPLES_PATH="$2"
			shift 2
			;;
		-d|--debug)
			DEBUG=true
			shift
			;;
		-m|--max-time)
			MAX_TIME="$2"
			shift 2
			;;
		-c|--cpp)
			RUN="./"
			shift
			;;
		-j|--java)
			RUN="java "
			shift
			;;
		-h|--help)
			help
			exit 0
			;;
		--)
			shift
			break
			;;
		*)
			echo "Invalid option."
			exit 1
			;;
	esac
done

# Colors and fonts.
GREEN='\e[32m'
RED='\e[31m'
NC='\e[0m' # No Color
DIM='\e[2m'
BOLD=$(tput bold)
NORMAL=$(tput sgr0)

# Create some temporary files.
temp_time_result=$(mktemp)
temp_stderr_file=$(mktemp)

# Draw a nice header.
echo -e "${BOLD}INPUT\t\tOUTPUT\t\tANSWER\t\tTIME (s)$NORMAL"

# Run the solver on all the samples in the samples folder.
for input in $(ls $SAMPLES_PATH/*.in) 
do
	# Set the answer file and answer from this file.
	answer_file="${input%in}out"
	answer="$(< $answer_file)"

	# Run the program and set the stdout and stderr outputs.
	stdout="$( ( time timeout $MAX_TIME $RUN$PROGRAM < $input 2> $temp_stderr_file ) 2> $temp_time_result)"
	stderr="$(< $temp_stderr_file)"

	# Filter the time the program took.
	time="$(grep real < $temp_time_result | awk '{print $2}' | sed 's/.*m//' | tr -d s)"

	# Check if there was a time-out, error or if the answer was right/wrong.
	(( $(awk 'BEGIN {print ("'$time'" >= "'$MAX_TIME'")}') )) && time="$RED$time$NC" && stdout="TIME-OUT"
	[[ "$stdout" == "" ]] && stdout="ERROR\t"
	if [[ "$stdout" == "$answer" ]]; then stdout="$GREEN$stdout$NC"; else stdout="$RED$stdout$NC"; fi

	# Remove preceding path from input file.
	input_file=${input##*/}

	# Print answer and debug info if the debug variable is set.
	echo -e "$input_file\t$stdout\t$answer\t$time"
	[[ $DEBUG = true ]] && [[ "$stderr" != "" ]] && echo -e "$DIM$stderr$NC"
done

# Remove the temporary files.
rm -f $temp_time_result $temp_stderr_file
