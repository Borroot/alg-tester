#!/usr/bin/env bash
# AUTHOR: Bram Pulles

source defaults

readonly GREEN='\e[32m'
readonly RED='\e[31m'
readonly DIM='\e[2m'
readonly BOLD='\e[1m'
readonly RESET='\e[0m'

readonly MAN_PAGE=./alg-tester.1

parse_options ()
{
	TMP=$(getopt "p:s:m:vxcj3h" "$@") || exit 1
	eval set -- "$TMP"

	while true; do
		case "$1" in
			-p)  PROGRAM="$2"                 ; shift 2 ;;
			-s)  SAMPLES="$2"                 ; shift 2 ;;
			-m)  MAX_TIME="$2"                ; shift 2 ;;
			-c)  TYPE=cpp                     ; shift   ;;
			-j)  TYPE=java                    ; shift   ;;
			-3)  TYPE=python                  ; shift   ;;
			-x)  STATS=true                   ; shift   ;;
			-v)  VERBOSE=true                 ; shift   ;;
			-h)  man "$MAN_PAGE"              ; exit 0  ;;
			--)  shift                        ; break   ;;
		esac
	done
}

process_cpp ()
{
	if [[ "$PROGRAM" =~ ^/ ]]
	then
		RUN="$PROGRAM"   # absolute path
	else
		RUN="./$PROGRAM" # relative path
	fi
}

process_java ()
{
	if [[ "$PROGRAM" =~ .jar$ ]]
	then
		RUN="java -jar $PROGRAM"
	else
		RUN="java -classpath $(dirname $PROGRAM) $(basename $PROGRAM)"
	fi
}

process_python ()
{
	RUN="python3 $PROGRAM"
}

process_options ()
{
	case "$TYPE" in
		cpp   )  process_cpp    ;;
		java  )  process_java   ;;
		python)  process_python ;;
		*) >&2 echo "Language '$TYPE' not supported."; exit 1
	esac
}

process_round ()
{
	if [[ "$stdout" == "$answer" ]]
	then
		format_output="$GREEN$format_output$RESET"

		round_time=$(tr -d ',.' <<< $time | sed 's/^0*//g')
		[[ *m* != $time ]] && let total_time+=round_time

		let correct++
		return
	fi

	format_output="$RED$format_output$RESET"
	local _MAX_TIME=$(tr -d 'smhd' <<< $MAX_TIME)

	if [[ $(awk "BEGIN {print ($time >= $_MAX_TIME && $_MAX_TIME != 0)}") == 1 ]]
	then
		format_time="$RED$format_time$RESET"
		stdout="TIME-OUT"
		return
	fi

	[[ "$stdout" == "" ]] && stdout="ERROR"
}

check_for_updates ()
{
	local branch=$(git rev-parse --abbrev-ref HEAD)
	if [[ "$branch" == "master" ]] && $(timeout .5 git fetch 2> /dev/null)
	then
		local local_hash=$(git rev-parse HEAD)
		local upstream_hash=$(git rev-parse master@{upstream})

		if [[ "$local_hash" != "$upstream_hash" ]]
		then
			echo There is an update, please type \`git pull\'.
		fi
	fi
}

format_init ()
{
	format_input=%-18s
	format_output=%-15s
	format_answer=%-15s
	format_time=%-8s
}

format_compose ()
{
	format="$format_input$format_output$format_answer$format_time"
}

print_header ()
{
	format_compose
	printf "$BOLD$format\n$RESET" INPUT OUTPUT ANSWER 'TIME (s)'
}

print_round ()
{
	format_compose
	local input_file=${input##*/}

	printf "$format\n" "$input_file" "$stdout" "$answer" "$time"
	[[ $VERBOSE == true && "$stderr" != "" ]] && >&2 echo -e "$DIM$stderr$RESET"
}

print_stats ()
{
	amount=$(ls "$SAMPLES"/*.in | wc -l)
	[[ $STATS == true ]] && echo -e You answered $correct/$amount correct in an average time of $(($total_time / $amount)) ms.
}

cleanup ()
{
	rm -f $tmp_time_file $tmp_stderr_file
}

check_for_updates
parse_options "$@"
process_options

correct=0
total_time=0

tmp_time_file=$(mktemp)
tmp_stderr_file=$(mktemp)
trap "cleanup; exit 1" INT TERM

format_init
print_header

for input in $(ls "$SAMPLES"/*.in)
do
	format_init

	answer_file="${input%in}out"
	answer="$(< $answer_file)"

	stdout="$( ( time timeout $MAX_TIME $RUN < $input 2> $tmp_stderr_file ) 2> $tmp_time_file)"
	stderr="$(< $tmp_stderr_file)"
	time="$(grep real < $tmp_time_file | awk '{print $2}' | sed 's/0m//' | tr -d s)"

	process_round
	print_round
done

print_stats
cleanup
